
\documentclass{article}

\hyphenation{MATLAB}

% The file ijcai11.sty is the style file for IJCAI-11 (same as ijcai07.sty).
\usepackage{ijcai11,times,graphicx,amsmath,float,multirow,bbm,amssymb}
\usepackage{times}

\title{Gesture Alignment Using Hidden Markov Models}
\author{
Andrew Hershberger
\quad Salman Ahmad \\
\{andrew.hershberger, saahmad\}@cs.stanford.edu
\\\\
Stanford University\\
CS228: Probabilistic Graphical Methods --- Winter 2011\\
}

\begin{document}

\maketitle

\begin{abstract}

Gesture recognition gaining interest in many domains. A common issue when
learning from multiple training gestures is accounting for noise and different
durations and speeds. This paper presents an algorithm that uses Hidden Markov
Models to align training gestures and learn the hidden canonical gesture that
they represent. The algorithm was used to align motion capture data from an
Xbox Kinect. This paper present initial results along with a discussion of
current limitations and paths for future work.

\end{abstract}

\section{Introduction}

Gesture recognition is becoming increasingly important in many fields from
gaming to user interface design. Since it is difficult to manually encode
gestures declaratively, there is a lot of interest in applying learning
techniques to train a classifier that can recognize gestures from motion
capture data.

A common problem with this approach is that the training examples are often
different durations and different speeds. This paper provides an algorithm
that aligns gestures based on the important actions that take place - e.g. the
start of a wave or the midpoints in a jump. Additionally, the algorithm
learns a canonical representation of the gesture that can be used for
classification of new data.

\begin{figure}
\begin{centering}
\includegraphics[width=0.4\columnwidth]{figures/control_points.pdf}

\caption{The location twenty control points that are tracked by the gesture alignment
algorithm.\label{figure:control_points}}

\end{centering}
\end{figure}

The algorithm was evaluated using motion capture information from an Xbox
Kinect. The raw RGBZ output was converted to \emph{(x,y,z)} positions of 20
different control points on the human body as shown in Figure
\ref{figure:control_points}. An alignment hidden markov model was then used to
align the different gestures.

The rest of this paper presents related work in this area, the graphical model
used to encode the independencies of the data, a discussion of the algorithm,
results, an analysis of current limitations, and logical areas of future work.


\section{Related Work}

Koller and Friedman \cite{Koller2009} provide an overview and analysis of
different approaches to solving sequence labeling problems like gesture
recognition. The hidden Markov model (HMM), a generative model, presents
the challenge of modeling a distribution over the observed variables. By
contrast, the maximum entropy Markov model (MEMM) and conditional random
field (CRF) are discriminative approaches in which only the conditional
distribution over the class labels must be modeled, thus avoiding the need to
model the distribution over the observed variables directly. On the other hand,
generative models may allow learning with less training data than would be
required in the discriminative case.

In one gesture recognition project, Wang et al.\ \cite{Wang2006} employed a
CRF variant called a hidden conditional random field (HCRF). Their approach,
however, did not address the issue of dealing with varying length gestures or
gestures that are compressed or expanded in time during various phases.

In a related study, Coates et al.\ \cite{Coates2008} addressed the problem of
learning an ideal pattern from multiple non-ideal demonstrations. They applied
an iterative expectation maximization (EM) algorithm for aligning multiple input
sequences while simultaneously learning the ideal target sequence. Their
approach interleaved iterations of a Kalman smoother and dynamic time warping.
The Kalman smoother \cite{Muphy2002} was used to determine the means and
covariance matrices of the hidden target sequence. The dynamic time warping
algorithm \cite{Listgarten2005} then determined the highest-likelihood mapping
of the observed sequences onto the ideal. Eventually this iterative process
converged producing tremendous results.

\section{Graphical Model}


\begin{figure}
\begin{centering}
\includegraphics[width=0.65\columnwidth]{figures/model_tau_unobserved.pdf}

\caption{The graphical model using for gesture alignment. $X$ represents the
hidden, ``canonical'' gesture. $Y$ represents the observed gesture from the
training set. $T$ represents an indexed mapping between the observed gesture
to the canonical gesture.\label{figure:model_tau_unobserved}}

\end{centering}
\end{figure}



\begin{figure}
\begin{centering}
\includegraphics[width=0.65\columnwidth]{figures/model_tau_observed.pdf}

\caption{An example graphical model once $T$ has been learned. In this case,
the second and third frames from the observed gesture maps to the second and
fifth frame of the canonical gesture. \label{figure:model_tau_observed}}

\end{centering}
\end{figure}



images of the model before and after dynamic programming approach to DTW

It's an alignment HMM

\section{Algorithm}

We decided to focus on the alignment HMM subproblem of the larger gesture
recognition problem. This is a particularly important issue in cases where it is
important to allow gestures of different speeds or of varying speed to be
recognized by the system.

We chose to follow the general approach outlined by Coates et al.\ 
\cite{Coates2008} where smoothing EM steps were interleaved with dynamic
time warping EM steps. We also did several things differently. First, we used
a local regression weighted linear least squares smoother. We turned to this
approach because the Kalman smoother requires a notion of a dynamics
model that is used to calculate the next state given the current state and noise.
In our case, generating such a model is infeasible because of the large
variation in the way different people perform the same gesture. Secondly, we
also did not incorporate prior knowledge about the ideal gesture. As discussed
later, such information is a key area for future work to explore what kinds of
prior knowledge can be incorporated to improve performance.

\subsection{Variables and Initialization}

The initialization of our algorithm involves all of the key variables. We initialize
an empty ideal trajectory $\mathbf{X}$ with length equal to twice the mean of
the observed training examples $\mathbf{Y}$. Next, an initial mapping is generated to
map each sample of each training example onto a sample of the ideal gesture.
This initialization is done by evenly distributing the samples from each training
sequence over the length of the ideal gesture sequence. The last major step in
initialization is setting initial values for the parameters $\mathbf{d}$ of the conditional
probability distribution of the index mapping for a sample given the index
mapping of the previous sample:
\begin{equation}
\mathbb{P}\left(T_{i+1} \mid T_{i}\right) = \left\{\begin{matrix}
d_{1} & T_{i+1} - T_{i} = 1\\ 
d_{2} & T_{i+1} - T_{i} = 2\\ 
%\multicolumn{2}{c}{\vdots} \\ 
\vdots & \vdots \\ 
d_{n} & T_{i+1} - T_{i} = n\\ 
0 & \textup{otherwise}
\end{matrix}\right.
\label{tau_dist}
\end{equation}
As is common practice, we initialize all of the entries in $d$ to be equal. The
choice of the maximum allowable step size $n$ from one index mapping to the
next was set to $3$ in the example we followed. As will be discussed, we explored
the effects of vary the value of this parameter.

\subsection{Calculating Ideal Gesture}

Instead of using the Kalman smoother to generate the normal distribution parameters
for each $X_j$, we simply calculated the mean and variance of the corresponding
$Y_i$ values as given by the current mapping $\mathbf{T}$. Since the mean for each
$X_j$ is used as the value for the ideal gesture, this unsmoothed result ends up being
quite choppy. To smooth things out we applied MATLAB's smooth function to our data,
using a local regression weighted linear least squares smoother. This approach gave
smoother results, but also led to decreased alignment performance.

\subsection{Calculating Optimal Mappings}

After calculating the new values for the distributions over $\mathbf{X}$, the mappings
$\mathbf{T}$ are updated. The dynamic time warping algorithm is used for this
process. The approach uses dynamic programming to efficiently compute the best
value of $T_i$ for every corresponding $Y_i$. As explained by Coates et al., the
algorithm can be defined by the following equations:
\begin{equation}
\label{qinit}
\mathcal{Q}\left(1,t\right)=\ell\left(y_1 \mid x_{T_1}, T_1=t\right)+\ell\left(T_1=t\right)
\end{equation}
\begin{equation}
\label{qsubsequent}
\begin{split}
&\mathcal{Q}\left(s,t\right) = \ell\left(y_s \mid x_{T_s}, T_s=t\right)+\\
&\max_{t^\prime}\left[\ell\left(T_s=t\mid T_{s-1}=t^\prime\right)+\mathcal{Q}\left(s-1,t^\prime\right)\right]
\end{split}
\end{equation}
For $s=1$, equation (\ref{qinit}) is used. In this case, all values where $t\neq1$ are
equal to $-\infty$ and so only the $t=1$ case need be computed.

Optimizing the algorithm when calculating q(:,:), tau;

Tried different allowed step sizes for d

\subsection{Convergence}

\section{Results}

SALMAN:




\begin{figure}
\begin{centering}
\includegraphics[width=\columnwidth]{figures/kick_aligned.png}

\vspace{0.1in}

\includegraphics[width=\columnwidth]{figures/kick_unaligned.png}

\caption{Motion capture data of a person performing a kick. Top: Data that has
been aligned with our algorithm. Bottom: The Original, unaligned data. Both
images were taken at the same time offset. \label{figure:kick}}

\end{centering}
\end{figure}





\begin{figure}
\begin{centering}
\includegraphics[width=\columnwidth]{figures/jump.png}

\caption{A failure case of our implementation. The algorithm does not have
domain specific information about the dynamics of the real world, for example,
gravity. The above data was taken from a person jumping. To align the data,
the algorithm ``freezes'' the person in mid-air when this is obviously
physically impossible. \label{figure:jump}}

\end{centering}
\end{figure}









Figures, writeup (we are geniuses).

\section{Discussion and Future Work}

ANDREW:

Why didn't it work very well? Smoothing made things worse.

Use different smoothing

Add prior knowledge of optimal trajectory: can incorporate effects of gravity
- don't want things to hang in mid air.

Application to classification problem

Add more data (training data)

Add features to detect particular aspects of gestures.

Detect orientation differences

\section{Conclusion}

This paper presents a method to perform gesture alignment using a Hidden
Markov Model. The algorithm was shown to be able to align certain gestures and
learn a canonical gesture. The method was applied to motion capture data that
was extracted from RGBZ images taken from an Xbox Kinect.

While the findings were some what promising it failed to work on a diverse set
of gestures. There are obvious areas for future work. First, the model should
incorporate our prior knowledge of the ideal gesture. For example, it would
certainly help to encode that during a kick, one of the legs will be
accelerating while the rest of the body stays still. Second, the algorithm
should incorporate a dynamics model of the real world. This will allow the
method to better deal with physical phenomenons like gravity.





\bibliographystyle{named}
\bibliography{CS228}

\end{document}
